# 单周期 CPU 的基础知识

- [单周期 CPU 的基础知识](#%e5%8d%95%e5%91%a8%e6%9c%9f-cpu-%e7%9a%84%e5%9f%ba%e7%a1%80%e7%9f%a5%e8%af%86)
  - [单周期 CPU](#%e5%8d%95%e5%91%a8%e6%9c%9f-cpu)
  - [CPU 执行指令的实际过程](#cpu-%e6%89%a7%e8%a1%8c%e6%8c%87%e4%bb%a4%e7%9a%84%e5%ae%9e%e9%99%85%e8%bf%87%e7%a8%8b)
  - [MIPS32 指令集子集](#mips32-%e6%8c%87%e4%bb%a4%e9%9b%86%e5%ad%90%e9%9b%86)
    - [由 ALU 负责的指令](#%e7%94%b1-alu-%e8%b4%9f%e8%b4%a3%e7%9a%84%e6%8c%87%e4%bb%a4)
    - [访存指令](#%e8%ae%bf%e5%ad%98%e6%8c%87%e4%bb%a4)
    - [转移指令（无条件或条件跳转）](#%e8%bd%ac%e7%a7%bb%e6%8c%87%e4%bb%a4%e6%97%a0%e6%9d%a1%e4%bb%b6%e6%88%96%e6%9d%a1%e4%bb%b6%e8%b7%b3%e8%bd%ac)
    - [我小组三人随机抽到的指令](#%e6%88%91%e5%b0%8f%e7%bb%84%e4%b8%89%e4%ba%ba%e9%9a%8f%e6%9c%ba%e6%8a%bd%e5%88%b0%e7%9a%84%e6%8c%87%e4%bb%a4)
  - [数据通路中的必要元素](#%e6%95%b0%e6%8d%ae%e9%80%9a%e8%b7%af%e4%b8%ad%e7%9a%84%e5%bf%85%e8%a6%81%e5%85%83%e7%b4%a0)

CPU 本质上就是一个数字逻辑电路，所以我们设计 CPU 的时候实际上就是在设计电路。我们在使用 Verilog 的时候，实际上是在利用 Verilog 硬件描述语言来设计 CPU 的逻辑电路结构。因此，我们需要：

- 先进行电路设计
- 再进行 Verilog 的代码编写

只有当我们的电路被清晰的分解为结构图中各个模块与模块之间的连接、模块内部的数据通路和状态机、数据通路中的电路逻辑以及状态机中的状态转换图，那么接下来的 Verilog 代码设计就是一个简单的「翻译」而已。

## 单周期 CPU

单周期 CPU（Single Cycle Processor）是指一条指令在一个时钟周期内完成并开始下一条指令的执行。由时钟的「上升沿」和「下降沿」控制相关操作。两个相邻的「上升沿」或「下降沿」之间的时间间隔就是 CPU 的「时钟周期」。

## CPU 执行指令的实际过程

一个 CPU 执行指令的基本流程是这样的：

|       |    步骤    |                                                                行为                                                                 |
| :---: | :--------: | :---------------------------------------------------------------------------------------------------------------------------------: |
|   1   |   取指令   | CPU 根据 PC（程序计数器 - Program Counter）中的指令地址，在指令存储器中获取相应的指令，之后 PC 的值会自动改变移动到下一条指令的地址 |
|   2   |  指令译码  |                                对获取的指令进行分析，确定这个指令要完成什么操作，改变相应的控制信号                                 |
|   3   |  指令执行  |                                          相关组件获取控制信号，执行相应操作，并将结果反馈                                           |
|   4   | 存储器访问 |                                如果指令设计读取、存储内存，则需要对存储器中相应地址进行读取或者写入                                 |
|   5   |  结果写回  |                                将得到的数据（访问存储器或者修改其它寄存器的值获得）写回相应的寄存器                                 |
|   6   |  循环 1-5  |                                                                 ...                                                                 |

## MIPS32 指令集子集

根据 MIPS32 指令集的设计，我们需要实现的指令有以下三种类型：

![](https://i.loli.net/2019/08/28/Utaqn6Hi8P2uygj.png)

所有的指令长度均为 32 比特。

根据实验要求，我们本次需要设计的指令共有这样几个：LUI、ADDIU、ADD、LW、SW、BEQ、J 以及一个抽签得到的指令（我的是 SUBU）。这些指令具体是这样的：

### 由 ALU 负责的指令

- `LUI`：将 16 位立即数 imm 写入寄存器 rt 的高 16 位，寄存器 rt 的低 16 位置 0
- `ADDIU`：：将寄存器 rs 的值与**有符号扩展**至 32 位的立即数 imm 相加，结果写入 rt 寄存器中
- `ADD`：将寄存器 rs 的值与寄存器 rt 的值相加，结果写入寄存器 rd 中。如果产生溢出，则触发整型溢出例外（IntegerOverflow）

![](https://i.loli.net/2019/08/29/IxHobe5zrAXSVUJ.png)

### 访存指令

- `LW`：将 base 寄存器的值加上符号扩展后的立即数 offset 得到访存的虚地址，据此虚地址从存储器中读取连续 4 个字节的值并进行符号扩展，写入到 rt 寄存器中（不对错误进行处理）
- `SW`：将 base 寄存器的值加上符号扩展后的立即数 offset 得到访存的虚地址，据此虚地址将 rt 寄存器存入存储器中（不对错误进行处理）

![](https://i.loli.net/2019/08/29/nmYfwMSDu3lWayC.png)

### 转移指令（无条件或条件跳转）

- `BEQ`：如果寄存器 rs 的值等于寄存器 rt 的值则转移，否则顺序执行。转移目标由立即数 offset 左移 2 位并进行有符号扩展的值加上该分支指令对应的延迟槽指令的 PC 计算得到
- `J`：无条件跳转。跳转目标由该分支指令对应的延迟槽指令的 PC 最高 4 位与立即数 `instr_index` 左移 2 位后的值拼接得到

![](https://i.loli.net/2019/08/29/LMIoTsnupXyRHjN.png)

### 我小组三人随机抽到的指令

- `SUBU`：将寄存器 rs 的值与寄存器 rt 的值相减，结果写入 rd 寄存器中
- `SRLV`：由寄存器 rs 中的值指定移位量，对寄存器 rt 的值进行逻辑右移，结果写入寄存器 rd 中
- `ORI`：寄存器 rs 中的值与 0 扩展至 32 位的立即数 imm 按位逻辑或，结果写入寄存器 rt 中

![](https://i.loli.net/2019/08/29/PgDXB7M9AHd6mhS.png)

## 数据通路中的必要元素

- 指令存储器（Instruction Memory）
- 数据存储器（Data Memory）
- 寄存器堆（Register File）
- 指令寄存器（Instruction Register）
- 程序计数器（Program Counter）

---

[👈 Previous](../1_Preparations/1-3_Editor.md) | [👉 Next](./2-2_Design.md) | [🚩 Home](../README.md)